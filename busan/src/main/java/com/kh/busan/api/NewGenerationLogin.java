package com.kh.busan.api;

public class NewGenerationLogin {
	
	// 새로운 로그인으로 넘어가기전 설명
	
	/*
	 * 로그인의 정의
	 * : 사용자가 입력한 값이 db에 있는지 조회하고 존재하면 사용자의 정보를 서버가 가지고 있어야함 
	 * + 세션 날라가기 전까지 내 세션에 사용자의 정보를 가지고 있어야함 
	 * 클라이언트랑 서버랑 쿠키를 보고 검증. 서버가 클라이언트의 상태를 세션이라는 저장소에 보관하고 있는 것(브라우저가 꺼지기 전까지 서버가 꺼지기 전까지 로그아웃 전까지)
	 * 
	 * 쿠키 : 클라이언트 저장소
	 * 세션 : 서버쪽 저장소 
	 * --> 둘다 각각 정보를 가지고 있어야함 
	 * 하나의 서버가 가지고 있을 수 있는 저장소의 공간이 제한되어있을 것(서버가 사용자의 정보만 가지고 있을 수 없음) -> 사용자의 정보만 올려둘 수 있음 요청이 들어오면 모두가 사용하는 공간이 됨 
	 * 그래서 => 뺵단 서버는 하나만 존재하는 것이 아니라 여러개의 서버가 존재할 것 
	 * 
	 * 클라이언트 A : 로그인 요청을 보냈으면 첫번째 서버가 자기 세션에 클라이언트 A의 정보를 담았음 근데 로그인하고 나서 게시물작성해야지!함 이떄 첫번째 서버가 다른일하느라 막힘
	 * 그럼 게시물작성요청은 B서버로 이동을 하는데 B서버는 A의 정보를 가지고 있지않음 -> 서버입장에서는 이 사람 누구야?가 되지만 사용자 입장에서는 자기가 어떤 서버로 갔는지 알 수가 없음 
	 * -> 이문제를 해결할 차선책이 필요 
	 * 
	 * 이젠 jsp에서 화면을 만들지 않음 == 서버에서 화면을 만들지 않고 리액트에서 앞단을 만듬==> 프론트와 백이 확실히 구분이 되었다
	 * 
	 * 레스트풀...?
	 * --------------------------------------------------------------------------------------------------------------------------------------
	 * 오늘날의 데이터통신은 클라이언트에 구애받지않음 서버는 json형태로 데이터만 바꿔서 보냄 (프론트랑 백이랑 따로 작업하므로 json으로 보내는것이 암묵적인 약속)
	 * -> 요청보낼때 요청 URL에 뭐 요청하는지 보내자 
	 * 
	 * 행위(만들어진 상태)는 메소드로 구분하자
	 * GET ==> 조회
	 * POST ==> 생성
	 * PUT ==> 수정
	 * DELETE ==> 삭제
	 * 
	 * Token기반 로그인 방식 -> 전에는 session에 사용자의 정보를 담아놨지만 token을 사용하면 session에 사용자의 정보를 저장하지 않고 사용 
	 * 
	 * 토큰은 개발자가 만들면 됨 -> 많은 개발자들이 이해하고 사용할 수 있는 상태로 만들어줘야함 
	 * 그럼 요새에는 데이터가 어떠한 형태로 만들어서 주고 받는것을 선호하는가 ? = JSON
	 * 토큰도 JSON형태로 만들어서 왔다갔다하는 것을 선호 => jwt.io
	 * 
	 * JSON 
	 * 헤더 + 페이로드 + 시그니처로 구성되어있음
	 * 
	 * -헤더-
	 * 어떠한 걸 가지고 암호화를 했는가 + 토큰의 유형
	 * (어떤 알고리즘을 가지고 있는지)
	 * 
	 * -페이로드-
	 * 실제로 전송하고자하는 클레임(사용자의 정보)
	 * sub: 일반적으로 사용자를 식별할 수 있는 식별자(pk ex.userNo)
	 * name: 사용자의 이름 또는 아이디
	 * iat: 발행한 시간이 언제인지(발행한 시간)
	 * -> 데이터 이므로 만들기 나름 (관리자인지 아닌지도 넣을 수 있음)
	 * 
	 * -시그니처(서명)-
	 * 해더랑 페이로드랑 인코딩 방식을 이용해서 인코딩한 값을 더함 그리고 비밀키를 이용해서 헤더에있는 알고리즘으로 해싱한 값
	 * 만료가 되지않았는지 요청한 사용자가 페이로드에 있는 사용자가 맞는지 확인하는 과정 
	 * 
	 * => 메소드 호출해서 만들어냄 
	 * 
	 * ----------------------------------------------------------------------------------------------------------------------------------------------
	 * 사용자가 아이디랑 비밀번호를 입력 -> 컨트롤러가 값을 받아 서비스로 넘김 -> 서비스에서 사용자가 입력한 값이 DB에 있는값과 일치하는지 검증을 거침 -> 검증에 성공할 수도 있고 실패할 수도 있음
	 * 실패를 하면 예외를 발생시키고 성공을 하면 jwt 토큰을 만들것 (사용자의 정보를 페이로드에 담은 토큰을 만들것) 토큰을 만들어서 contorller에서 클라이언트에게 응답을 해줄 것 
	 * -> 여기서 만든 토큰을 axios의 then으로 받아서 사용자측 저장소에 토큰을 저장할 것 -> 저장을 하고 클라이언트가 인증이 필요한 요청(글쓰기, 정보수정, 댓글작성등 로그인되어있어야지 이용할 수 있는 기능)할떄마다 요청헤더에 포함시켜서 요청을 보낼 것 
	 * -> 그럼 서버는 저런 요청이 들어올때만 토큰을 받아서 그 사용자가 받은 토큰이 맞나 확인하는 과정을 거칠 것 동일한 토큰이면 사용자가 기능이용 가능할 수 있음 
	 * 
	 * ==> 토큰을 사용하면 무결성 보장 / 서버 낭비를 줄임 
	 * 
	 * 토큰의문제점
	 * 토큰을 클라이언트의 저장소에 넣어두면 탈취의 위험이 있음 그래서 토큰을 만들때 유효기간(만료기간)을 만들어놓음(개발자가 기간 지정하는 것) 만료기간이 길 수록 보안에 취약함
	 * (보통 1일(access토큰)로 해놓고 refresh토큰(만료기간 7일)을 만들어놓음(한번 만들때 두개를 같이 만들어)
	 * 두개를 같이 주는데 refresh토큰은 db에 저장을 해놓음 
	 * access토큰이 만료가 되면 db에서 refresh토큰을 가지고 있으면 사용자가 맞는지 확인을 하고 사용자가 맞다면 다시 access토큰을 발급해줌 
	 * access토큰을 6일 발급해줄 수 있는 것 -> refresh토큰 이것도 만료가 되면 로그인을 풀어버림 그리고 다시 토큰을 생성(서버가 만료시간을 가지고 있어서 이걸 비교)
	 * 
	 * => 토큰을 검증하는 과정이 필요한데 뒷단에서는 검증을 해야함 이 시점을 언제로 해야하는가? dispatcher에서 인터셉터로 넘어갈 때 잡아야함 전처리니깐 ---> 이걸 도와주는 프레임워크가 존재 == Spring Security
	 * 
	 * 토큰을 보내면 서버는 비밀키를 가지고 잇음 
	 * 
	 * --------------------------------------------------------------------------------------------------------------------------------------------------
	 * SpringSecurity 
	 * : Filter기반의 인증 인가 및 보안에 대한 기능을 제공하는 프레임 워크 
	 * 
	 * -Filter
	 * 클라이언트 요청이랑 디스패처 서블릿 사이 에서 도는것이 Filter (클라이언트 요청이 디스패처 서블릿에 도달하기 전까지에서 도는것)
	 * 
	 * 디스패처 서블릿이랑 인터셉터 
	 * 
	 * - 인증: 사용자의 신원을 증명하는 과정
	 * - 인가: 사용자가 요청하는 자원을 실행할 수 있는 권한의 있는가를 확인하는 과정 
	 * 
	 * 어떻게 인증. 인가할것인지 통일화 시킨것 프레임워크로 만들어 놓은것이 스프링 시큐리티라고 할 수 있음 
	 * 
	 * 클라이언트가 요청을 보내면 제일 먼저 톰캣(서블릿컨테이너를 돌리고 있음)이 요청을 받는다 -> 서블릿 컨테이너 안에 스프링 애플리케이션 -> 스프링 컨테이너 -> 디스페처 서블릿 
	 * ->  필터는 디스페처 서블릿이 받기 전에 동작을 함 (필터는 한개 또는 여러개를 둘 수 있음) -> 필터에서 디스패처 서블릿으로 이동할 것 -> 최종적으로 디스패처 서블릿으로 갔다는것은 마지막 필터로 갔다는것 
	 * 
	 * 
	 * 스프링 컨테이너 안에서 스프링 시큐리티가 동작을 할 것 이게 필터들을 엄청 많이 가지고 있음 -> 이걸 빈으로 등록해서 스프링이 관리하게 해서 사용 (스프링 빈으로 등록)
	 * 근데 문제점은
	 * 필터는 스프링 필터 돌아가기 전에 서블릿 컨테이너에서 동작을 함 -> 디스패처 서블릿에서 동작을 하는것 스프링에서는 동작을 하지 않음 -> 스프링 시큐리티에서 만들어진 빈은 밖에서 사용이 불가
	 * 이걸 해결하기 위해  
	 * 빈을 사용할 수 있는 클래스를 만듬(DelegatingFilterProxy) 
	 * -> DelegatingFilterProxy는 포장 바구니 같은 것 / 실제 사용하는 것은 filterChainProxy라는 클래스가 실제로 사용 이때 필요한게 SecurityFilterChain
	 * 
	 * filterChainProxy = Sping Security에서 제공하는 Filter
	 * 
	 * 
	 */

}
